---
title: "New Taipei Income per Household (Tax Year 2022)"
author: "User"
execute-dir: project
format: html
---

```{r}
#| label: setup
knitr::opts_knit$set(
  root.dir = rprojroot::find_rstudio_root_file()
)
```


```{r}
#| include: false
# Font setup for Chinese characters
library(showtext)
library(sysfonts)

# Change your font file path if needed
sysfonts::font_add(
  family = "noto_tc",
  regular = "font/NotoSansTC-Regular.ttf" # path to your font file
)

showtext::showtext_auto()

ggplot2::theme_set(
  ggplot2::theme_minimal(base_family = "noto_tc")
)
```


## Setup

```{r}
library(dplyr)
library(readr)
library(sf)
library(ggplot2)
library(stringr)
library(ggmap)
```

## Load data

CSV includes a UTF-8 BOM; read with the matching encoding and keep the English headers provided in the codebook.

```{r}
income_path <- "data/income_distribution_by_village_2022_newTaipei.csv"
income_raw <- read.csv(income_path, check.names = FALSE, fileEncoding = "UTF-8-BOM")

dglimpse <- function(df) {
  tibble::tibble(
    n_rows = nrow(df),
    n_cols = ncol(df),
    sample_region = df$`Region Name`[1]
  )
}
dglimpse(income_raw)
```

## Calculate mean income per household

Rename columns to concise snake_case and compute `mean_income_calc = total_income / tax_units`. The dataset already reports a mean; we calculate it to verify consistency.

```{r}
income_ntpc <- income_raw %>%
  rename(
    region = `Region Name`,
    village = `Village Name`,
    tax_units = `Tax Units (Households)`,
    total_income = `Total Comprehensive Income`,
    mean_income_reported = `Mean Income`
  ) %>%
  mutate(mean_income_calc = total_income / tax_units)

income_ntpc %>%
  select(region, village, tax_units, total_income, mean_income_reported, mean_income_calc) %>%
  slice_head(n = 5)
```

## Validate reported mean vs. calculated mean

Check that the reported mean matches the calculation across all villages.

```{r}
income_ntpc %>%
  mutate(diff = mean_income_reported - mean_income_calc) %>%
  summarize(
    max_abs_diff = max(abs(diff), na.rm = TRUE),
    mean_abs_diff = mean(abs(diff), na.rm = TRUE)
  )
```

## Top and bottom villages by calculated mean income

Review extremes to understand the spread.

```{r}
# Top 5
income_ntpc %>%
  arrange(desc(mean_income_calc)) %>%
  select(region, village, tax_units, mean_income_calc, mean_income_reported) %>%
  slice_head(n = 5)

# Bottom 5
income_ntpc %>%
  arrange(mean_income_calc) %>%
  select(region, village, tax_units, mean_income_calc, mean_income_reported) %>%
  slice_head(n = 5)
```

## Notes

- Monetary unit is not stated in the CSV; based on similar MOF tables it is likely thousand NTD—confirm with source metadata.
- If differences appear between reported and calculated means, revisit unit assumptions and rounding rules from the source.

## Map: classify mean income into low/mid/high

Use the official village boundaries shapefile, keep only New Taipei, join on `COUNTYNAME + TOWNNAME + VILLNAME`, and classify the calculated mean income into terciles.

```{r}
shp_path <- "data/raw/村(里)界(TWD97經緯度)1141031/VILLAGE_NLSC_11401031.shp"
villages_sf <- st_read(shp_path, quiet = TRUE) %>%
  st_transform(3824) %>%  # GCS_TWD97[2020] / EPSG:3824
  filter(COUNTYNAME == "新北市") %>%
  mutate(join_key = paste0(COUNTYNAME, TOWNNAME, VILLNAME))

income_ntpc_geo <- income_ntpc %>%
  mutate(
    county = "新北市",
    district = str_remove(region, "^新北市"),
    join_key = paste0(county, district, village),
    mean_class = ntile(mean_income_calc, 3),
    mean_class = factor(mean_class, levels = 1:3, labels = c("Low", "Mid", "High"))
  )

income_map <- villages_sf %>%
  left_join(income_ntpc_geo, by = "join_key")

income_map %>%
  summarize(
    matched = sum(!is.na(mean_class)),
    missing = sum(is.na(mean_class))
  )
```

### Choropleth

```{r}
y_range <- diff(range(st_bbox(income_map)[c("ymin", "ymax")]))

top3 <- income_map %>%
  filter(!is.na(mean_income_calc)) %>%
  arrange(desc(mean_income_calc)) %>%
  slice_head(n = 3) %>%
  st_centroid()

bottom3 <- income_map %>%
  filter(!is.na(mean_income_calc)) %>%
  arrange(mean_income_calc) %>%
  slice_head(n = 3) %>%
  st_centroid()

ggplot(income_map) +
  geom_sf(aes(fill = mean_class), color = NA) +
  scale_fill_manual(
    values = c("Low" = "#d4eac7", "Mid" = "#74c476", "High" = "#006d2c"),
    na.value = "gray90",
    name = "Mean income (tercile)"
  ) +
  geom_sf_label(
    data = top3,
    aes(label = paste0(village, " (", round(mean_income_calc, 1), ")")),
    nudge_y = y_range * 0.08,
    size = 3,
    label.size = 0
  ) +
  geom_sf_label(
    data = bottom3,
    aes(label = paste0(village, " (", round(mean_income_calc, 1), ")")),
    nudge_y = -y_range * 0.08,
    size = 3,
    label.size = 0
  ) +
  labs(
    title = "New Taipei: Mean Comprehensive Income per Household (2022)",
    subtitle = "Villages grouped into terciles of calculated mean income"
  ) +
  coord_sf(clip = "off") +
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold"),
    plot.margin = margin(10, 30, 10, 30),
    text = element_text(family = "Noto Sans TC")
  )
```

### Top 3 villages only

```{r}
library(ggplot2)
library(dplyr)
library(sf)

# [Logic Preserved] Calculate range for label nudging
y_range <- diff(range(st_bbox(income_map)[c("ymin", "ymax")]))

# [Logic Preserved] Define labels for Top 3 (Centroids)
top3 <- income_map %>%
  filter(!is.na(mean_income_calc)) %>%
  arrange(desc(mean_income_calc)) %>%
  slice_head(n = 3) %>%
  st_centroid()

# [New] Define Polygons for Top 3 (for the Choropleth)
# We need the actual geometry, not just centroids, to draw the map
top3_poly <- income_map %>%
  filter(!is.na(mean_income_calc)) %>%
  arrange(desc(mean_income_calc)) %>%
  slice_head(n = 3)

# [Plot] Use top3_poly as the main data source
ggplot(top3_poly) +
  geom_sf(aes(fill = mean_class), color = NA) +
  scale_fill_manual(
    values = c("Low" = "#d4eac7", "Mid" = "#74c476", "High" = "#006d2c"),
    na.value = "gray90",
    name = "Mean income (tercile)"
  ) +
  # Only keeping the Top 3 labels
  geom_sf_label(
    data = top3,
    aes(label = paste0(village, " (", round(mean_income_calc, 1), ")")),
    nudge_y = y_range * 0.008,
    size = 3,
    label.size = 0
  ) +
  labs(
    title = "New Taipei: Mean Comprehensive Income per Household (2022)",
    subtitle = "Top 3 Villages by calculated mean income"
  ) +
  coord_sf(clip = "off") +
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold"),
    plot.margin = margin(10, 30, 10, 30),
    text = element_text(family = "Noto Sans TC")
  )
```
### Overlay Stadia map

```{r}
library(ggplot2)
library(dplyr)
library(sf)
library(ggmap) # Using ggmap as requested

# --- SETUP STADIA MAPS ---
# You MUST register your API key for this to work.
# register_stadiamaps("YOUR_API_KEY_HERE", write = FALSE)

# 1. Transform data to WGS84 (EPSG:4326) required for ggmap
# We transform the whole map first to get the correct subset
income_map_wgs84 <- st_transform(income_map, 4326)

# 2. Filter Top 3 Data (Polygons & Labels)
top3_poly <- income_map_wgs84 %>%
  filter(!is.na(mean_income_calc)) %>%
  arrange(desc(mean_income_calc)) %>%
  slice_head(n = 3)

top3_labels <- top3_poly %>%
  st_centroid()

# 3. Define Bounding Box for the Basemap
# Add a small buffer so the polygons aren't cut off at the edge
bbox <- st_bbox(top3_poly)
names(bbox) <- c("left", "bottom", "right", "top") # ggmap naming convention
# Expand box slightly (optional, prevents tight cropping)
bbox_expanded <- bbox
bbox_expanded["left"] <- bbox["left"] - 0.01
bbox_expanded["right"] <- bbox["right"] + 0.01
bbox_expanded["bottom"] <- bbox["bottom"] - 0.01
bbox_expanded["top"] <- bbox["top"] + 0.01

# 4. Fetch the Stadia Map
# Note: zoom needs to be tweaked based on the size of your area. 
# 12 is usually city-wide, 14 is district level.
basemap <- get_stadiamap(
  bbox = bbox_expanded, 
  maptype = "stamen_toner_lite", 
  zoom = 13,
  force = TRUE
)
```


```{r}

# 5. Plot
ggmap(basemap) +
  # inherit.aes = FALSE is crucial when mixing ggmap + sf
  geom_sf(data = top3_poly, aes(fill = mean_class), color = NA, alpha = 0.85, inherit.aes = FALSE) +
  scale_fill_manual(
    values = c("Low" = "#d4eac7", "Mid" = "#74c476", "High" = "#006d2c"),
    na.value = "gray90",
    name = "Mean income (tercile)"
  ) +
  geom_sf_label(
    data = top3_labels,
    aes(label = paste0(village, "\n(", round(mean_income_calc, 1), ")")),
    # Nudging in ggmap (lat/lon) requires much smaller values than projected coords
    nudge_y = 0.005, 
    size = 3,
    label.size = 0,
    inherit.aes = FALSE
  ) +
  labs(
    title = "New Taipei: Mean Comprehensive Income per Household (2022)",
    subtitle = "Top 3 Villages (Stamen Toner Lite via ggmap)"
  ) +
  # coordinate system is handled by ggmap, but we can turn off clip
  coord_sf(clip = "off") + 
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold"),
    plot.margin = margin(10, 30, 10, 30),
    text = element_text(family = "Noto Sans TC")
  )
```
### Overlay Google Maps

```{r}
library(ggplot2)
library(dplyr)
library(sf)
library(ggmap)

# --- STEP 0: REGISTER GOOGLE API KEY ---
# 1. Get key at: https://console.cloud.google.com/
# 2. Enable "Maps Static API"
# 3. Paste key below:
# register_google(key = "YOUR_GOOGLE_API_KEY", write = FALSE)

# --- STEP 1: Process Data (Projected CRS) ---
top3_poly_projected <- income_map %>%
  filter(!is.na(mean_income_calc)) %>%
  arrange(desc(mean_income_calc)) %>%
  slice_head(n = 3)

top3_labels_projected <- st_centroid(top3_poly_projected)

# --- STEP 2: Transform to WGS84 ---
top3_poly_wgs84   <- st_transform(top3_poly_projected, 4326)
top3_labels_wgs84 <- st_transform(top3_labels_projected, 4326)

# --- STEP 3: Define Center & Zoom ---
# Google Maps works best with a center point + zoom level, rather than a bbox
center_point <- st_coordinates(st_centroid(st_union(top3_poly_wgs84)))
mean_lon <- center_point[1]
mean_lat <- center_point[2]

# --- STEP 4: Fetch Google Map ---
gmap_base <- get_googlemap(
  center = c(lon = mean_lon, lat = mean_lat),
  zoom = 13,          # Adjust: 12 (City), 13 (District), 14 (Detailed)
  maptype = "roadmap", # Options: "roadmap", "satellite", "hybrid", "terrain"
  style = "feature:all|element:labels|visibility:off" # Optional: Turns off Google's own labels to reduce clutter
)

# --- STEP 5: Plot ---
ggmap(gmap_base) +
  geom_sf(
    data = top3_poly_wgs84, 
    aes(fill = mean_class), 
    color = "black",
    size = 0.5,
    alpha = 0.7, 
    inherit.aes = FALSE
  ) +
  scale_fill_manual(
    values = c("Low" = "#d4eac7", "Mid" = "#74c476", "High" = "#006d2c"),
    na.value = "gray90",
    name = "Mean income (tercile)"
  ) +
  geom_sf_label(
    data = top3_labels_wgs84,
    aes(label = paste0(village, "\n(", round(mean_income_calc, 1), ")")),
    nudge_y = 0.003, # Google Maps zoom requires fine-tuning nudge
    size = 3,
    label.size = 0,
    fontface = "bold",
    inherit.aes = FALSE
  ) +
  labs(
    title = "New Taipei: Mean Comprehensive Income per Household (2022)",
    subtitle = "Top 3 Villages (Google Maps Background)"
  ) +
  coord_sf(clip = "off") +
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold"),
    plot.margin = margin(10, 30, 10, 30),
    text = element_text(family = "Noto Sans TC")
  )
```

